Java é uma das maiores linguagens com empregabilidade.
Flexibilidade; remuneração
Sistemas web-> back-end +  banco de dados - requisições web- front-end
API Interface de programação: é o que está exposto para o front
API REST é um padrão que estabelece regras como Cliente/servidor com HTTP, comunicação stateless(*); Intergace uniforme e sistemas em camadas.
Usando protocolo HTTP para realizar ações com verbo http: get(pegar), post(inserir), put(salvar) , delete
Padrão camadas:
Cada camada tem um responsabilidade.
Controladores REST
  Data transfers Objects
Camada de serviço
  Entities/ORM
Camada de acesso a dados

Docker -> É uma plataforma de conteinerização.
Um container é como uma “caixinha” que empacota sua aplicação com tudo que ela precisa (código, dependências, bibliotecas, configurações, etc.).
Assim, a aplicação roda de forma igual em qualquer lugar: no seu PC, em um servidor ou na nuvem.

Postman -> Postman
É uma ferramenta para testar APIs (REST, GraphQL, SOAP, etc.).
Com ela, você pode enviar requisições HTTP (GET, POST, PUT, DELETE...) e ver a resposta da API.
É muito usado por devs backend para testar endpoints sem precisar criar uma interface ainda.
Também ajuda a documentar e compartilhar coleções de requisições da API com o time.
lib Maven


Curso Nelio-> Interfaces
Interface é um tipo que define um conjunto de operações que uma class deve implementar.
Um contrato que a classe deve ser, baixo acoplamento.

Relacionamento definem como as classes ou entidades se ligam entre si.
TIPOS:
Associação: uma classe conhece a outra
Associação direta entre classes gera um acoplamento forte, com dois pontos de manutenção(ruim)
-Agregação:todo-parte podem existir separadamente.
-Composição todo-parte forte é um tipo de relacionamento entre classes onde uma depende da outra para existir.Dependentes.
Herança: uma classe herda atributos e comportamentos de outra extends, relacionamento é-um
Dependência: uma classe usa temporariamnete outra, relacionamento amis fraco.
Tipos de objetos->
Views,Responsáveis pela interface com o usuário (HTML, JSP, Thymeleaf, API JSON, etc.).
Controllers,Recebem as requisições do usuário, chamam os services e devolvem a resposta.
Entities,Representam os objetos do mundo real no sistema
Services,Contêm a regra de negócio. O Controller pede algo → o Service processa
Repositories.A camada de acesso a dados. Consultas ao banco de dados ficam aqui.

Interface define o que deve ser feito mas não como. Você implementa ela em outra classe.
Serviços que dependem entre si existe um auto-acoplamento porém não é uma boa parte pois ficam dependentes, uma vez que se for alterar precisa de dois pontos de alteração.
Em termos de manutenção é ruim. -> Usando Interface que define um contrato  faz as outras classes dependerem dela.
Na interface tem um contrato(método) abstrato e a classe filha implementa esse método.Acoplamento fraco com um ponto de mudança.


Inversão de controle retirar da própria classe a responsabilidadede instanciar suas dpendencias.
Injeção de dependência por meio de construtor/classe de instanciação/container framework
Forma de realizar a inversão de controle, um componenteexterno(main) instancia a dependencia que é então injetada no objeto pai.

Exercicío de fixação Section 16
//Uma empresa deseja automatizar seus contratos. Utiliza um serviço de pagamento online para pagar parcelas.
//Os serviços de pagamento online cobram juro mensal,e uma taxa por pagamento.
//Por enquanto,o serviço contratado pela empresa é o do Paypal,que aplica
//juros simples de 1% a cada parcela,mais uma taxa de pagamento de 2%.

//Programa deve conter os dados de um contrato, ler número de meses para parcelamento do contrato e gerar registros de parcelas.
//A primeira parcela a ser paga deve ser após um mês da data do contrato ...

RESOLVENDO EXERCÍCIO TEORIA:
UML->
Classe associada com um asterisco representa uma associação de um para muitos
Um contrato está associado a muitas parcelas

entities
Installment
gerar um atributo estático DateTimeFormatter fmt = DateTimeFormatter.ofPattern(dd/mm...);
declarar os atributos desse classe, criar construtor sem parâmetros e o com parâmetros, criar getters e setters.
gerar toString para imprimir os dados na tela depois no main(arrumar date formatada)

Contract
declarar os atributos desse classe, criar construtor sem parâmetros e o com parâmetros, criar getters e setters.
Um contrato está associado a muitas parcelas-> para representar essa associação de muitos vc declara uma lista de
installments

Main
Scanner
sout(Entre os dados)
int number = sc.nextInt();
DateTimeFormatter fmt= DateTimeFormatter.ofPattern(dd/mm...);
LocalDate date = LocalDate.parse(sc.next());
Instancia o contrato com os parâmetros(pq vc já leutodos eles)

sout(Entre números de parcelas)
int n = sc.nextInt();


Service
OnlinePaymentService - interface

ContractService- classe com método; declarar OnlinePaymentService pois é uma dependência
gerar construtor com lógica da dependência
método
método para gerar parcelas, passando Contract e var int months de parâmetro)

var double basicQuote para gerar uma parcela básica getTotalValue do contract / months
for(int = 1 ; 1<=months; i++)
{LocalDate dueDate= contract.getDate().plusMonths(i)
fazendo lógica para gerar parcela a cada mês

double interest = onlinePaymentService.métodointerest(basicQuote,i)
double fee= onlinePaymentService.paymentFee(basicQuote + interest)

valor total das parcelas  double quota = basicQuote + interest + fee;

Agora adicio9nar esses dados como um objeto Installment

contract.getInstallments().add(new Installment(dueDate,quota));

PaypalService implements OnlinePaymentService
método(double amount)  que retorna *0,02 sobre amount
método (double amount, int months)
retirn amount * 0.01 * monsths


Main
Instanciar ContractService com argumento new PaypalService
chamar contractService.método()
sout(Imprimir parcelas)
for(Installment installment : obj.getInstallment) -> chamar o getInstallment para ler os dados de cada parcela


//DOMAIN LAYER DESIGN (entities)-> representam as entidades do domínio(criar dentro do pacote entities)
//SERVICE LAYER DESIGN -> representam a lógica de negócio e como o sistema usa as entidades (fazer dentro do pacote services)

No UML quando tem um * do lado de uma classe e uma ligação entre duas classe representa uma relação um para muitos em que a classe com asterisco é muitos.
Na classe que tem muitos vc representa o muitos com uma lista com o nome da classe muitos.

Regras:
1 → exatamente um.
0..1 → zero ou um.
* → muitos (zero ou mais).
1..* → pelo menos um (um ou muitos).

07/09/2025
Diferença entre herdar e cumprir contrato
Aspectos comuns entre herança e interfaces: relação é-um Circulo é uma Forma e TaxaBrasil é uma Taxa
Generalização/especialização e polimorfismo onde um var pode ser associada de acordo com seus objetos

Diferença->
Herança tem o reuso de comportamentos e interface é só um contrato a ser cumprido, vc só implementa

E se vc tem uma interface e tbm quer ter um atributo reutilizável para todas as figuras??
Tem que repetir os atributos em cada classe? Não, vc cria a interface q define o contrato, cria uma classe abstrata com seu atributo e classes q herdam extends a classe abstrata e q implementam implements o contrato
Shape interface com método
public abstract class AbstractForma implements Shape
Clss Circle extends AbstractForma
declarar vars do tipo AbstractForma

Herança múltipla não roda em java pois não tem como ter reuso, vc apenas implemeta mais de um contrato
problema diamante->ambiguidade causada pela existência do mesmo método em mais de uma superclasse
Classe genérica e classe específicas e outra classe q herda mais de uma superclasse

Exemplo
Disposito classe abstrata método process
Impressora extends Disposito e overreide seu método process
Scanner extends Disposito e overreide seu método process de outra forma , implementações diferentes
Aqui são duas classes específica onde cada uma tem uma implementação
ComboDispositivo extends Impressora , Scanner ERRADO NÃO TEM COMO UMA CLASSE HERDAR MAIS DE UMA CLASSE

Para isso deve usar interface->

Disposito classe abstrata método process
Interface Impressora
Interface Scanner
Classe Impressora extends Device implements Scanner
Classe Scanner extends Device implements Impressora
ComboDispositivo extends Disposito implements Scanner,Printer -> aqui você pode implementar duas interfaces
tendo obrigação de implementar tudo q está nas interfaces eliminando ambiguidades.

Interface Comparable
public interface Comparable<T>{
int compareTo(T o)
}
Comparable é uma interface genérica do Java (java.lang.Comparable<T>) usada para definir a ordem natural de objetos.
Ela serve para que seus objetos possam ser comparados entre si de forma consistente, permitindo:
Ordenar listas (Collections.sort() / list.sort()).
Inserir em estruturas ordenadas (TreeSet, TreeMap).
Comparar manualmente (obj1.compareTo(obj2)).
Programa q ler um arq com nomes de pessoas, armazenando os em uma lista. Depois ordenanr os dados dessa listya
e mostra-los na tela

Main
declara main
Declara uma Lista -> List <String> list = new ArrayList<>();
Declara uma String path = "C:\\";


Criar na pasta um arq com o caminho e os nomes

ISSO AQUI É TRY-WITH-RESOURCES
try(BufferedReader br = new BufferedReader(new FileReader(path))){  declara a classe arquivo
String name = br.readLine();  lê a linha
while (name != null){ enquanto a linha não for nula ela adiciona o nome na lista
list.add(name);
name = br.readLine();
}
Collections.sort(list)  uma forma de ordenar os dados de uma lista
for(String s : list){
sout (s)
}catch(IOException)
}


ler arq .csv contendo funcionários, em q cad alinha do arq cntem um obj e não um dado
colocar no arq os dados dos funcionarios

Criar uma classe funcionário implements Comparable<Funcionario> com atributos, construtor e getters e setters
e adicionar método compareTo que vai comparar um objeto com outro
Quando vc comparra um obj com obj ele retorna int com return comparando nomes.
Main
Declarar lista de Funcionario
try(BufferedReader br = new BufferedReader(new FileReader(path))){
String funcionarioCsv = br.readLine();
while (name != null){
String[] campos = funcionarioCsv.split(",")   aqui ele declarou um vetor que recebe o objeto que lê cada linha e dividiu oos dados com ,

}
list.add(new Funcionario(campos[0],Double.parseDouble(campos[1]))
funcionarioCsv = br.readLine();
}Collections.sort(list)  uma forma de ordenar os dados de uma lista
 for(Funcionario fun : list){
 sout (fun)
 }catch(IOException)
 }

Classe Collections método sort srve com List<T> list onde só pode ordenar a lista do tipo T se for do tipo comparable
Assim, vc deve implementar a interface Comparable


Default Methods = definir implementação padrão de métodos para evitar repetição e evitar criar classes abstartaas para ter reuso de implementação.
Interfaces podem conter métodos concretos
Cria uma interface e tem clases que implementam essa interface
potêncica Math.pow
Interface não pode ter contrutor

Section 17 -> Generics, Set, Ma
Generics permitem que classes,interfaces e métodos possam ser parametizados por tipo. Uso comum em coleções
 List<String> list = new ArrayList<>();
 list.add("Maria");
 String name = list.get(0);
Aqui vpcê consegue definir e ter a certeza de que o elemento retornado vai ser uma String

Programa q le n e n números interios. Ao final exibir o primeiro valor. Implementar o PrintService que vai realizar um
serviço de impressão
PrintService<T>
Lista de inteiros List<T>
com método addValue(T value)
método T first()
return list.get(0)
método imprimir lista for i < list.size i++
list.get(i)

Main vc instanciar a classe com nseu tipo
sout(Quantos valores:)
le com scaneer


PrintService<Integer> ps = new PrintService<>() aqui só entre int
PrintService<String> ps = new PrintService<>() aqui só entre string


for i=0;i<n;i++{
Integer value = sc.next
ps.addValue(value)
}

E se eu quiser add Strings e não inteiros?
Como reusar esse código? Torna-lo genérico
Criar uma classe parametizado com tipo T, q vai dar pra rusar e garantir typesafety

O T é um placeholder (um tipo genérico) que será substituído por um tipo real quando você criar a lista.
Ele serve para o compilador garantir segurança de tipos (type safety).


Genéricos delimitados->
São restrições que você coloca em um parâmetro genérico (T) para limitar quais tipos podem ser usados.
Com extends → você diz que o tipo genérico deve ser uma subclasse (ou implementar uma interface).
Com super → você define que o tipo genérico deve ser uma superclasse.

class Caixa<T extends Number> {
    private T valor;

    public void guardar(T valor) {
        this.valor = valor;
    }

    public T abrir() {
        return valor;
    }
}

Nesse caso, T só pode ser um subtipo de Number (Integer, Double, Float, etc.).
Se você tentar Caixa<String>, vai dar erro, porque String não é um Number.

public <T extends Comparable<T>> T maximo(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}
Aqui, o método só aceita tipos que implementam Comparable (como Integer, String, etc.). Assim o compilador sabe que pode chamar compareTo.

Tipos curinga->wildcard types <?>
generics são invariantes, List<Object> não é um supertipo de qualquer tipo de lista e sim List<?> ; um tipo curinga que pode receber um genérico de qualquer tipo

Porém não dá para adicionar dados a uma lista de qualquer tipo, pq o compilador não sabe o tipo d alista que foi instanciada

Curinga delimitados-> São curingas que possuem restrições de tipo com extends ou super
Curinga delimitado superior (? extends)    Ler (entrada segura, saída limitada)
Significa: “algum tipo que herda de ...”
Garante que você pode ler da lista como o tipo pai, mas não pode adicionar novos elementos (exceto null).
public void imprimir(List<? extends Number> lista) {
    for (Number n : lista) {
        System.out.println(n);
    }
}não consegue fazer lista.add(10), porque o compilador não sabe se a lista é de Integer, Double, etc.

Curinga delimitado inferior (? super) Escrever (inserção segura, leitura limitada)
Significa: “algum tipo que é superclasse de ...”
Garante que você pode inserir elementos do tipo especificado ou seus filhos, mas só pode ler como Object.

HashCode e Equals
        Class Object É a superclasse de todas as classes em Java,Se você não declara explicitamente de quem uma classe herda, ela automaticamente herda de Object.
        public class Paciente {
            // na prática é como se fosse:
            // public class Paciente extends Object
        }


        Métodos-> toString =Retorna uma representação em texto do objeto.
        equals(Object obj)=Compara se dois objetos são “iguais”.

HashCode e equals server para comparar se um obj é igual a outro
equals retorna true ou false
hashcode Retorna um número inteiro que representa o objeto, é um código gerado por uma função, dados iguyais tem o mesmo código gerado
POREM ESSE CÓDIGO PODEM DAR COLIsões pois só tem 32bytes de espaço
Se o código de dois objetos são iguais provavelmente são iguais(pode ter colisões)
MUITO RÁPIDO PARA COMPARAR.
Se tem colisão vc confirma com o método equals

Comparar se clientes são iguais qunado tiverem o mesmo nome email
generate hashcode e equals selecionar os atributos e vai gerar implementação padrão
== compara posições na memória, estão se vc comparar dois objetos com mesmo dado vai dar false, porém se vc escrever em "" e não declarar um obj com new vai comparar os dados e não a posição



Set<T> -> não tem posição e repetição
conjunto de elementos, uma interface com implementações->
add(obj), remove(obj), contains(obj)(verifica se obj existe na coleção)
clear()
 • size()
 • removeIf(predicate)
 • addAll(other) - união: adiciona no conjunto os elementos do outro conjunto, sem repetição
 • retainAll(other) - interseção: remove do conjunto os elementos não contitos em other
 • removeAll(other) - diferença: remove do conjunto os elementos contidos em other

HashSet
Usa tabela hash internamente.
Não garante ordem dos elementos.
Muito rápido para adicionar, remover e buscar.
 Set<String> set = new HashSet<>();
 set.add("TV");
 set.add("Notebook");
 set.add("Tablet");
 System.out.println(set.contains("Notebook"));
 for (String p : set) {
 System.out.println(p)

LinkedHashSet
Mantém a ordem de inserção.
Mais lento que HashSet, mas previsível.
Set<Integer> numeros = new LinkedHashSet<>();
numeros.add(3);
numeros.add(1);
numeros.add(2);
System.out.println(numeros);

TreeSet
Mantém os elementos ordenados (ordem natural ou via Comparator).
Mais lento, mas útil quando você precisa de ordenação automática.

Set<Integer> numeros = new TreeSet<>();
numeros.add(3);
numeros.add(1);
numeros.add(2);
System.out.println(numeros);


Set testa igualdade
se sua classe básica tiver haschcode equals compara com eles por conteúdo, senão iver vai comparar as referÊncias dos objetods

TreeSet compara elementos
usa o compareTo, para usar tem q implements no nome da classe Comparable<Classe> para que o TreeSet ordene os objetos

EXERCÍCIO
 Um site de internet registra um log de acessos dos usuários. Um
 registro de log consiste no nome de usuário (apenas uma palavra) e o
 instante em que o usuário acessou o site no padrão ISO 8601,
 separados por espaço, conforme exemplo. Fazer um programa que leia
 o log de acessos a partir de um arquivo, e daí informe quantos usuários
 distintos acessaram o site.

LER ARQ DE ENTRADA COM DADOS DE PESSOAS Q ACESSAM HORÁRIO E DIZ NO FIM QUNATOS USUARIOS DISTINTOS ACESSARAM O SITE
criar classe para representar entrada dos usuarios com atributos username e Date moment
para saber quantos usuarios diferentes acessaram devemos comparar os nomes
Assim criar um haschcode equals
Na main vc faz bufferedReader e FileReader
try
Criar um Set<Classe> new HashSet pq a ordem não importa
recortar string com vetor e função split
String [] fields=line.split("")
String username = fields[0]
Formatar data
Date monet = Date.from(Instant.prse(fields[1]))
set.add(new Class())


Exercício de Set= Fazer

Map ->
Estrutura de dados genérica com pares chave/valor
É como um dicionário: cada chave (K) é única e aponta para um valor (V).
Métodos=
• put(key, value), remove(key), containsKey(key), get(key)
put inserir                     verificar se existe chave  recupera elemento pela chave
 Uso comum: cookies, local storage, qualquer modelo chave-valor

 keySet() retorna um set do map percorrendo chaves e valores

 Quando você precisa associar um identificador único a um valor

 Comparação das coleções
 Estrutura	O que é?	                                                Permite duplicados?	                   Ordenação	                                                                                       Exemplo prático
 List<T>	Lista ordenada de elementos indexados (cada item tem posição).	✅ Sim	                              Mantém a ordem de inserção (ex: ArrayList), ou pode ser ligada (ex: LinkedList).	                     Lista de alunos de uma sala ([Ana, João, Ana]).
 Set<T>	Conjunto de elementos únicos (não aceita duplicados).	             ❌ Não	                           Pode não ter ordem (HashSet), manter ordem de inserção (LinkedHashSet) ou ordenar naturalmente (TreeSet).	Conjunto de CPFs ({111, 222, 333}).
 Map<K, V>	Estrutura de pares chave → valor. Cada chave é única.	 ❌ Chaves não podem repetir (mas valores podem).	HashMap não garante ordem, LinkedHashMap mantém inserção, TreeMap ordena por chave.	            CPF → Pessoa ({111 → Ana, 222 → João}).

 Exercício Map -> fazer